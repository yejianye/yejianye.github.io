---
layout: post
title:  "从Software Developer到Tech Lead"
---

这是每个程序员在公司内升迁的必经之路。Tech Lead说白了是一个介于Manager与Developer之间的角色。做为一个TL，依然要继续Coding，但同时也要管理下属和项目的进度。当然一般来说与Manger相比，TL的下属人数一般不会很多。

TL往往是从Developer中技术能力较强者提拔上来的，这是一个悲剧的开始。因为基本上一个人的Coding能力与Geek程度是成正比的，但Geek大部分不善言辞，不善与人沟通。更悲剧的是，一个CS的本科生在第一天踏入工作的时候，他之前就已经有了4年的Programming的专业知识。而一个Tech Lead在上任之前完全没有任何专业培训。所这种角色转变注定是痛苦而又漫长的。

不过其实要减轻痛苦也不是很难，关键是要确定目标。首先，怎样的Tech Lead才能算是优秀的？前面说到TL的主要职责是管理下属的Developer以及项目的进度，当然很多时候他依然要担当Programmer的角色。

如何管理下属让他们按时完成所布置的任务？
--------------------------------

一个TL面临的第一个问题经常是“为什么我手下的人怎么都那么弱呢？这么一点事要做两个星期？写出来的Code还这么烂？WTF“ 这个…其实…如果他们的Coding比你强，你能当上Tech Lead吗？所以手下人的能力不如你，那是完全一定以及肯定的。所以TL的首要任务是要将自己的技术心得与秘技向下属倾囊相授，帮他们做大量的Code Review，Critical Path的代码需要逐行分析。和他们一起做项目模块的Break-down，Break-down做好了Project ETA的Estimation自然会变得更准确。我觉得Tech Lead最重要的职责是Mentoring，下属的技术与实现效率提高了，其他问题也就迎刃而解了。

说到这里就不得不提到我刚刚升TL时的一个坏习惯，就是”最硬的骨头一定要自己来啃“。其实这不是成为TL后养成的习惯，因为之前就是一路啃硬骨头上来的。不过现在是该把这些好差使留给你的Team member的时候了，这就好比打电脑游戏，你的主角等级已经很高了，即使再杀几个BOSS也升不级，但这些经验如果让给队伍里等级较低的角色，那他们可以连升好几级，队伍的整体实力也更强了，要是一天到晚让他们杀些lv1, lv2的小怪，再过个一年半哉，他们也还是老样子。当然在跟BOSS打的时候，你的主角一定要在旁边盯着，关键时刻给点红瓶蓝瓶，或是放个大招把怪打掉半条血什么的，不然他们怎么死的你都不知道。

有人问，那一段时间之后我手下的人技术上都比我厉害了怎么办？我觉得到那时你就可以升Manager了，TL让他们来做吧。

如何继续做好自己的另一项本职工作，Coding ?
------------------------------------

这是一个很头痛的问题，除去用在Mentoring与Meeting上的时间不算，在剩下的时间里TL做为很多方的Contact point，一天之中会被打断无数次，而Programming是最忌讳被打断的。曾经问过我们的CTO，他是如何解决这些问题的？（不要奇怪，我所在的Slide是一家100多人的Startup，即便是CTO也还是要Coding的) 他的方法是人为的制造一段Dedicate的时间来Coding，具体来说就是他会每天早上8:00到公司，比一般员工要早2个小时，这2个小时他会把需要处理的最难的Coding problem解决掉。当然一般来说他也会比大部分人早1,2个小时下班。虽然没有正面解决被打断的问题，也是一个很不错的approach。可惜这个方法对很多人不适用，比如我，早起对我来说实在是一件太痛苦的事情。另外一些小的技巧，比如在想要专注的时候，可以关掉mail client与IM，这样别人只有在遇到真正棘手的问题时才会跑到你的Cubic来跟你讨论。

但总体来说，对于这个问题，我并没有解决之道。求高人指教！

如何保持自己技术上的优势？
--------------------

前面提到要不惜全力的培养下属，不过Tech Lead在骨子里都是希望自己的技术更出类拔萃。那这两者不是相互矛盾吗？我并不这样认为。TL应该在更High-level或是更Low-level方面思考问题，不是具体某段代码怎么写，某个模块如何写。在High level方面，应该考虑产品的整体Architecture，抽象出表现，逻辑与数据层，决定哪些技术是成熟的可以使用的，哪些技术是不成熟的或是即将被淘汰的。而在Low level方面，应该Thinking of CPU cycles, memory allocation, thread concurrency与network latency，了解底层的机制，才可能写出真正高效与健壮的代码，再好的产品理念，没有优秀的实现，那也注定会一败涂地。这也是在面试的时候，我很在意侯试人是否是科班出生的原因，在80%以上的工作中，CS科班出生的新手程序员相比那些经验丰富的自学程序员工作效率上要差一个档次，但是在一些关键点上前者会处理的更妥当。我可以很负责的说，即使CS的教材已经落后了一个时代，只要我们还是使用冯诺依曼的计算机模型，有没有认真学习本科的那些CS课程对将来工作会产生很深远的影响。

