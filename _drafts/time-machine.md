---
layout: post
title:  程序员的时间机器
summary: 时间机器可能是在科幻小说中出现次数最多的最终兵器。虽然在现实世界中它不可能被实现，但在程序的世界里它却可以成为最有用的工具。
---
时间机器可能是在科幻小说中出现次数最多的终极武器，但同时它也最不可能在现实世界中实现。

现在我给万能的时间机器加上两个限制条件

1. 它只能回溯过去，但不能展望末来。
2. 它只能观测，而不能修改历史。

这台阉割版的时间机器依然强大，有了它，历史上的任何疑难悬案都可以迎刃而解。这就好像在世界上的每一个角落都安装了监视摄像头。想象一下，这似乎并不是那么遥不可及。我不知道哪天人类会发明它，也不知道这是福是祸，但我知道它对程序员一定很有用。

其实，今天大部分程序员都已经在使用一台时间机器，它的名字叫“Git”。软件代码的版本控制可以说是至今为止软件工程上最伟大的发明之一，但我们知道一个程序有三个主要的状态，包括程序代码，它运行时的状态，以及它持久化的数据（如数据库里的数据）。虽然在代码这一层，我们已经可以做时间旅行了。但后面两个状态的时间机器在哪里？这就是我们今天要分享的话题。

不可变的数据
-----------
要实现时间机器，我们需要保存历史上发生过的所有状态。这里就必须提到一个最要的概念，那就是不可变数据（Immutable Data）。它的核心概念是数据就好像历史，它只表示了在过去的某个时间点上对象的状态，这是已经发生，不能被改变或销毁。但我们可以添加新的历史，它是一个全新数据，代表了在一个新的时间点上对象的状态。在这种理念下，要查看一个对象在某个特定时间点上的状态，就变得非常简单了，所以不可变数据是实现时间机器的基础。

可惜在传统的编程语言中，大部分数据结构都是可变的，比如当你向一个数组添加一个元素时，数组的内容就发生了变化。此后，我们就再也访问不到这个变化之前的数组了。

不过近些年来，不可变数据的优点被越来越多的人发现。这个曾经只在函数式编程语言中使用的概念，开始被主流编程语言所接受，并开始广泛的使用。比如，Facebook就开源了著名的 Immutable.js，从此不可变数据进入了 Javascript 的生态圈。在它的主页上有一段对于不可变数据的概述，说得非常到位，所以忍不住想引用，原文如下

    Immutable collections should be treated as values rather than objects. While objects represent some thing which could change over time, a value represents the state of that thing at a particular instance of time. 
   
程序运行状态的时间机器
-------------------
“最难调试的 Bug，就是那些无法每次都重现的 Bug”，这句话我想大部分有经验的程序员都深有体会。如果你有一个时间机器，可以把时间精确地拔回错误出现的那一刻，去观察当时的程序状态，以及后续发生的所有事件，那世界该有多美好。

在前端开发的世界里，这个问题已经被一个名为 Dan Abramov 的大神解决了，他的方案就是大名顶顶的 Redux 框架。Dan 大神不但做了框架，就连时间机器本身都在他的 [redux-devtools](https://github.com/gaearon/redux-devtools) 里替你实现了。如下图所示，你可以拖动时间轴来观察程序的历史状态，不但是程序的内部数据状态，就连界面的每一次更改都可以看得清清楚楚，请看下图

![Redux Devtools Time Machine](/images/redux-slider-monitor.gif)

对于 Redux 还不熟悉的同学，这里简单介绍一下它的工作原理。

- 整个程序的状态，统一地由一个 Applicate State 对象管理。这个对象的值是一个不可变数据。
- 程序状态的改变由各种 Action 导致。这里的 Action 可能是用户的输入事件，可能是网络请求事件，或是其他自定义的事情。一个 Action 要更改程序的状态，它必须生成一个新的 Application State，而不是更改现有的。
- 程序的界面完成由当前的 Application State 来决定。

Redux 只要记录下历史上所有的 Action 与对应的 Application State。所以 Redux 不但能还原程序每一刻的状态，还能还原与每个状态相关联的 Action，这相当于开启了调试者的上帝视角，如下图所示。真正的好东西往往就是这样，如此简单，却又如此强大。

最近在 JS 的生态圈里又看到了另一个有趣的项目 [Automerge](https://github.com/automerge/automerge)，它主要解决的问题是程序状态在多个设备间的同步。不过，我可以把它简单称为 Git for Application State。它本身也是基于不可变数据的，提交更改时还可以附一个 Commit Message，并支持用 `getHistory` 来查看所有的历史更改记录。是不是很有意思？

无论是 Redux 还是 Automerge，它们都可以被用来打造浏览程序运行状态的时间机器。但这些技术更适用于前端，而不是后端，因为在后端的世界，服务程序本身往往只有很少量的状态，绝大部分的状态在数据存储层，也就是数据库或是文件。这里要用到不同的技术，也是我们下节要讨论的重点。

数据存储的时间机器
----------------
程序的稳定运行固然重要，但比程序崩溃更严重的是，数据出错或是丢失。这里我指的不是由于数据库系统崩溃造成的数据问题，而是由于程序的逻辑错误导致的。全库的数据备份可以一定程度上解决这个问题，比如你想要了解某条数据在一个月前是什么值，或许你可以通过调出当时的备份查看，但对于海量数据库来说，代价极大。如果你想知道某条数据在历史上的所有更改，这时备份就完全帮不上忙了。这时你一定希望你的数据库若配备一个时间机器功能。

在如今的大数据时代，我们不但想记录事情的结果，而且恨不得将用户的一举一动全部记录下来，比如我们不但想记录下用户买单时购物车里有什么，我们还想知道在购物过程中用户曾经在购物车里放进哪些商品。这时，你会更想要一个数据库的时间机器。

在前文中，我们已经了解，时间机器的基础是不可变性，那有没有基于不可变原则的数据库呢？其实目前如日中天的区块链技术算是一个，但你要真用来它来代替 MySQL，这个还是算了吧。这里值得一提的是 Datomic，这个名字对于大部分人来说是陌生的，但它的主要作者就是 Clojure 语言的创造者 Rich Hickey。在 Clojure 语言中所有的数据结构都是不可变的，所以 Rich 基于同样的理念写了 Datomic 这个不可变的数据库。

Datomic 有多牛呢，可以说它就是数据库版的 Git。和 Git 一样，Datomic 是分布式的，没有中心服务器集群。它是不可变的，数据库从创建开始的所有历史都会被记录下来，每一个事务可以写文档注释，相当于 Git 的 Commit Message。它有自己的一套声明式的查询语言，与 SQL 不同，但也非常强大。但由于这个数据库是商用闭源的，并且与 Clojure 有着千丝万缕的关系，使得它在 Clojure 社区之外影响力有限。

大家都明白，数据库迁移的代价是很大，很多大型系统根本不可能从现有的 SQL 关系型数据库里迁出来，所以就算 Datomic 很酷，我们也只能看着流流口水。那有没有办法在不换数据库系统的前提下，达到我们的目的呢？办法总是有的，这里提供三种思路

1. 自己在 SQL 数据库上实现版本系统，给每个记录添加版本号，每次改动更产生一条新版本的记录。
2. 创建单独的日志表，在每次数据变更时，向日志表添加一条更改记录，记录操作类型，以及更改后的值。
3. 利用数据库自带的变更日志，来保存记录的所有历史版本。

1）的实现代价最大，只可能用于新项目。2）由于在 SQL 中 INSERT 与 UPDATE 语句都不会返回更改后的记录，所以需要用额外的查询去读取记录变更后的完整值，所以实现起来也不容易。我认为3）是开销最小的方案，但具体实现方式因系统而异，下面简单介绍一下在 MySQL 中如何实现。

首先要打开 MySQL 的 binlog，并将格式设为 row。

```
log-bin = /path/to/log
binlog_format=row
```

这样 MySQL 就会将数据库中每一行的插入或是更新都完整记录下来，这就是我们想要的数据库更改历史。但因为 binlog 是二进制格式，所以还要有一个工具来提取 binlog 里记录，并将它们保存到目标存储里。这里的目标存储可以是另一个数据库，或是分布式文件系统（如 HDFS）。

[Maxwell](http://maxwells-daemon.io/) 是 Zendesk 公司开源的一个读取 MySQL binlog 内容，并发送到 Kafka/Redis/RabbitMQ 等消息队列工具中。配置很简单，官网上也写得很清楚，这里就不再赘述。对于每条数据更新，它的输出是一个 JSON 对象，例如

```
mysql> insert into test.foo set id = 1, name = 'fire';
maxwell: {
  "database": "test",
  "table": "foo",
  "type": "insert",
  "ts": 1449786310,
  "xid": 940752,
  "commit": true,
  "data": { "id":1, "name": "fire" }
}
```

只需将 Maxwell 产生的这些 JSON 持久化存储，将来就可以查询原始数据库中任意记录在任意时间点上的值了。

人生的时间机器
----
在本文的最后，我来开一个脑洞，能为程序打造时间机器固然有用，但若能创建一部记录人生的时间机器岂不是更棒。其实我觉得这天或许不会太遥远，我们可以带上一副 Google Glass 将自己所见所闻一刻不停的全部录下来，所有的这些录像通过无线网络上传至云端永久保存，这样我们就可以随时调出人生的某一个时刻回顾，无论是工作中的一次重要会议，还是与家人的一段美好时光。

不仅如此，因为每一段录像都带有时间与位置信息，利用 AI 还可以对录像的内容进行分析，例如认别出录像中的人物，场景或是提取出录像的主题。这样我们就自己的时间线上做各式各样的搜索。比如像我这样丢三拉四的人，下次再找不到东西，就可以直接搜索与该物品相关的录像画面，这解决了我人生的一大痛点。

梦想是美好的，但在美梦成真之前，我还是建议大家平日里多写写日记，记录下自己的生活点滴与突发奇想，这是每个人现在就可以拥有的低配版的人生时间机器。

今天的分享就到这里，欢迎大家留言讨论。

扩展阅读
-------
[The Value of Values with Rich Hickey](https://www.youtube.com/watch?v=-6BsiVyC1kM)
[Dan Abramov - Live React: Hot Reloading with Time Travel](https://www.youtube.com/watch?v=xsSnOQynTHs)
