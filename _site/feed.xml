<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>叶剑烨的个人注释</title>
    <description>停顿十秒钟，思考沉淀</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Jekyll and Org together</title>
        <description> &lt;h1&gt;Section One&lt;/h1&gt;
&lt;p&gt;Hello Orgmode&lt;/p&gt;
 </description>
        <pubDate>Thu, 18 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/18/orgtest/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/18/orgtest/</guid>
      </item>
    
      <item>
        <title>程序员的核心能力 - 构建快速反馈</title>
        <description>&lt;p&gt;程序员的大部分时间都处在“运行代码，出错，修改代码”这样一个循环中，它被称为“反馈循环（Feedback Loop）”。反馈循环转得越快，单位时间里你可以迭代的次数就越多，你的编程效率也就提高了，这是一个很简单的道理。所以在做任何项目的时候，在你埋头到具体问题的调试之前，你首先要优化反馈循环的时间。&lt;/p&gt;

&lt;p&gt;那反馈循环的时间都花在哪儿了呢？&lt;/p&gt;

&lt;p&gt;也许你是一个移动应用工程师，为了验证一个 API，你每次都要在应用里提交一个复杂的表单，你的时间浪费在了重复填写表单上。也许你是一个数据工程师，你正在调试的一个数据查询时需要读取海量的数据，每次运行都至少要几分钟的时间。也许你在做的项目代码庞大依赖众多，每次的编译都要花上十来分钟。&lt;/p&gt;

&lt;p&gt;一个慢的反馈循环不但使你的时间浪费在等待中，让你心情不佳，也会打断你的思路，所以你实际上的效率损失很可能远大于表面上浪费的时间。写了这么多年程序，对于加快调试时的反馈时间，有些心得可以与大家分享。&lt;/p&gt;

&lt;h2 id=&quot;repl&quot;&gt;REPL&lt;/h2&gt;
&lt;p&gt;许多解释型语言，像是 Python, Ruby, Node 都有 REPL 环境（Read-Eval-Print-Loop），你可以在里面输入一些语句，立即就可以看到结果，这就是一个快速的反馈循环。目前主流的代码编缉器都有插件与这些 REPL 整合，在写代码的时候可以一边在主文件里写，一边让代码在 REPL 中执行，从而即时地检验代码的正确性。&lt;/p&gt;

&lt;p&gt;程序员在写代码的时候，头脑里会不断产生各种疑问，“这个正则表达式能匹配这个字符串吗？”，“这个函数调用的参数写对了没有？”，这些疑问不管对错，在它们被证实之前都会对头脑产生额外负担。在你写下一句代码的时候，头脑还是会忍不住思考上一句的正确性。REPL 能快速回答你头脑里的这些疑问，从而提升了你的思考效率。&lt;/p&gt;

&lt;p&gt;我当初学 C/C++/Java 这些编译型语言的时候，它们是没有 REPL 工具的，我也一度认为 REPL 是解释型语言的专利。但现在我发现 Swift, Kotlin 这些现代的编译型语言都原生提供了 REPL。而像 Go, Rust 等也都有第三方实现的 REPL，除此之外还有它们官网上的 Playground。所以现今无论你用哪种语言，几乎都能找到可用的 REPL 工具，赶紧用起来吧！&lt;/p&gt;

&lt;h2 id=&quot;mock&quot;&gt;Mock&lt;/h2&gt;
&lt;p&gt;有时你调试的功能依赖一个很慢的外部输入，这可能是一个远程的第三方API（尤其是国外的API），也可能是需要在界面上做人工输入，或是查询一个庞大的数据库表。这导致你调试的大部分时间都是在等待中渡过。解决这个问题的一个方法就是用 Mock 输入来代替真实输入。对一个远程的 REST API，你可以通过直接返回一个本地的 JSON 对象来代替。对人工界面输入，你可以在测试时让系统预填好所有的表单。对于庞大的数据库表的操作，你可以在本地创建一个相同结构的表，只取原本数据表中的少量数据复制到本地。这些设置在初期可能会花掉你一部分时间，但很快就能从调试过程中省回来。&lt;/p&gt;

&lt;p&gt;许多编程语言还提供了好用的 Mock 类库，以 Python 为例&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;unittest.mock&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patch&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@patch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'module_name.expensive_api'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mock_api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;awesome_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expensive_api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上面这段代码中，&lt;code class=&quot;highlighter-rouge&quot;&gt;expensive_api&lt;/code&gt; 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;awesome_func&lt;/code&gt; 中会自动被替换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;mock_api&lt;/code&gt;，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;awesome_func&lt;/code&gt; 之外则保侍不变。&lt;code class=&quot;highlighter-rouge&quot;&gt;patch&lt;/code&gt; 方法不但让替换逻辑清晰，而且让替换只作用于要调试函数。&lt;/p&gt;

&lt;h2 id=&quot;cache&quot;&gt;Cache&lt;/h2&gt;
&lt;p&gt;与 Mock 输入类似，Cache 是解决外部依赖执行速度慢的另一种方法。因为构建 Mock 也会引入一些意想不到的问题，比如 Mock 的结果与真实情况可能有差异，所以把费时的外部依赖函数的结果 Cache 起来也是个很不错的方法，但前提是这些依赖函数是“纯函数”。换句话说，就是这些函数的执行结果只取决于函数的参数，与任何全局状态无关，并且在函数执行后，除了返回数据外，没有任何副作用。顺便提一句，尽量把大部分函数写成纯函数也是一个重要的编程能力。&lt;/p&gt;

&lt;p&gt;这里的 Cache 不能用 in-memory cache，不然每次改代码重新运行的时候，Cache 就失效了。在调试时，File Cache 是很常用方法，也就是把函数执行的结果序列化后存在文件里，下次可以直接从文件里读。&lt;/p&gt;

&lt;p&gt;写函数 Cache 的时候时，不要把 Cache 的逻辑直接写在函数里。以Python为例，我不推荐以下的写法&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;slow_api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'{}_{}.json'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# 在这里执行函数原有逻辑&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# 将最后结果存入result变量&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'w'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这有两大缺点。第一，这段 Cache 的逻辑你需要在每个要用的地方都写一遍。第二，这段 Cache 的逻辑入侵了函数内部逻辑，不但清理起来麻烦，也容易不小心破坏原有逻辑。&lt;/p&gt;

&lt;p&gt;好的 Cache 实现要用到高阶函数。普通函数用来变换数据，高阶函数则用来变换其他函数。这个对初学者来说，可能有点难。但在主流语言中，大部分的通用类库大牛们都已经为大家实现了，所以只要会用就行了。比如 beaker 就是 Python 中处理 Cache 的第三方库，也支持用文件做为 Cache 的存储媒介。以下是使用 beaker 的代码示例&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;beaker.cache&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheManager&lt;/span&gt; 
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;beaker.util&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_cache_config_options&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;cache_opts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;'cache.type'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'file'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;'cache.data_dir'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'/tmp/cache/data'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;'cache.lock_dir'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'/tmp/cache/lock'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CacheManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_cache_config_options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache_opts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@cache.cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;slow_api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，在 CacheManager 对象初始化之后，对任何要加 Cache 的函数，只需要在它前面加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;@cache.cache()&lt;/code&gt; 就可以了，用起来很方便，也完全没有入侵性。&lt;/p&gt;

&lt;h2 id=&quot;日志记录&quot;&gt;日志记录&lt;/h2&gt;
&lt;p&gt;在代码执行的一些关键点打印日志也是让反馈循环转得更快的好方法。对于执行时间长的函数，在中间节点打印日志可以在整个函数执行完之前，提前提供反馈。不过日志更重要的作用是在单次反馈中给到你更多有用的信息，从而减少解决问题所需的反馈循环的次数。&lt;/p&gt;

&lt;p&gt;注意这里推荐使用的是 Log 而不是 Print。虽然从功能上讲两者是类似的，但相比 Print，日志记录有太多的优点。首先，日志可以提供不同的级别。通过给开发环境与生产环境设置不同的日志级别，你完全可以把调试时的日志代码提交，不用担心它会拖慢生产环境。而 Print 语句在提交前是必须清理干净的。日志记录还可以自动加上有用的上下文信息，比如当前时间，当前执行的模块与函数等。上下文信息既可以是日志模块内置的，也可以是你自定义的，比如在 Web 系统中你可以加上当前用户的 ID 做为上下文的一部分。这些上下文信息可以很好地帮助你排查错误。&lt;/p&gt;

&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;
&lt;p&gt;只要你调试的程序可以方便地写单元测试，那它就是构建快速反馈的最优方案，这也通常是我的第一选择。上面提到的很多方法与单元测试也是相辅相成的。比如 REPL 让你在写代码的过程中得到快速反馈，单元测试则可以在函数写完后提供整体检验。为了减少单元测试的外部依赖，或是为了让它运行得更快，Mock 方法在单元测试中经常用到。日志记录也可以帮助你在每次单元测试失败时看到更详尽的信息，让你更快速地定位错误原因。&lt;/p&gt;

&lt;h2 id=&quot;开发与调试工具&quot;&gt;开发与调试工具&lt;/h2&gt;
&lt;p&gt;最后一点也很重要，你要确保自己正在使用最好的开发与调试工具。好的构建工具可以加快你项目的编译速度，从而节省了反馈时间。有些工具则更进一步，例如顶顶大名的 React Hot Loader，它让对 React 代码的修改在页面上实时反应，而不需要重新加载页面，这样的工具大幅减少了反馈循环的时间。工欲善其事，必先利其器。千万不要小看工具的力量，工具的差异可能会造成效率上巨大的差距。以后会单独写文章聊聊如何打磨你的工具箱。&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;“快速反馈”是一个泛用性很广的概念，提升编程效率只是它的一个应用而已。&lt;/p&gt;

&lt;p&gt;几乎所有的电子游戏中都有一套高效的反馈机制，刷完任务立刻掉宝升级，甚至打怪的过程中也是各种数字乱飞，这一切都是对玩家的行为给予即时反馈。在体育训练时教练的重要性在于，他可以对你动作的正确性做出快速反馈。为什么很多公司喜欢把 KPI 实时地投到电视机上，并放在办公室最醒目的位置，就是把你每时每刻的工作“即时反馈”到公司的 KPI 上。即便这种即时性是一种幻觉，仍能激励员工。&lt;/p&gt;

&lt;p&gt;所以当你想要改善某件事的时候，先想一想如何建立一个快速反馈机制。比如你想提高代码单元测试的覆盖率，如果你只是把这个做为季度目标，那十有八九是完成不了的。但如果你每周都在例会上展示当前的单元测试覆盖率，那你达成目标的成功率就会大大提升。如果你建立一个git hook，在每次代码提交时都会显示当前的单元测试覆盖率，还显示与上次提交相比这个覆盖率变化了多少，那你百分之百会达成这个目标。这就是快速反馈的力量。&lt;/p&gt;

&lt;p&gt;在本文的最后，推荐一个视频，&lt;a href=&quot;http://v.youku.com/v_show/id_XMzUyOTIyNzg0.html&quot;&gt;Bred Victor - Inventing on Principle&lt;/a&gt;，它把快速反馈的概念展示得淋漓尽致，到现在我仍能记得5年前看这个视频时的震撼。在我看过的所有的技术演讲里，它绝对排在前三。希望它也能对你的思想带来冲击与启发！&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/10/feedback-loop/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/10/feedback-loop/</guid>
      </item>
    
      <item>
        <title>程序员的核心能力 - 引擎式思维</title>
        <description>&lt;p&gt;在编程技术飞速发展的今天，一方面大家的开发效率越来越高，但另一方面也越来越焦虑，内心的独白是“我每天拼死拼活的学了一堆东西，但现在学的几年之后就过时了，那时程序员这碗青春饭就吃不下去了…” 这是一个很现实的问题，但发现它后仍置之不理的话，几年后你就会陷入困境。那该如何解决呢？有人说做几年技术之后转型管理，这是完全可行的，但不是今天我们要聊的话题。如果是继续做技术，你需要找到一些核心的技术能力。它们使你更快速地工作，产生更高质量的成果，不容易被后来者超越，最最重要的一点是，不会因为某项技术的过时而失去价值。我希望通过接下来的几篇文章，和大家分享我的想法，今天讲的第一项核心能力，我称它为“引擎式思维”。&lt;/p&gt;

&lt;p&gt;当你写程序的时候，除了要解决眼前的问题，你有没有想过将来是否会需要解决类似的问题。把你的解决方案从解决一个问题扩展到解决一组问题是一项非常重要的能力，也往往是区分新人与资深技术人员的一条分界线。大家都知道写游戏的时候，会先写一个核心引擎，它把显示游戏场景、粒子系统、物理模拟等游戏中最普遍的问题抽象在了一个代码库中，这部分的逻辑会在游戏中被不断重用，甚至在多个游戏中重用。在有了引擎之后，上层的游戏开发人员就可以把精力集中在游戏内容的制作上。把你代码中普适的、可重用的部分与具体业务逻辑分离的思想，就是引擎式思维。在游戏中我们叫它引擎(Engine)，在应用开发中我们叫它框架(Framework)，在基础服务里我们又叫它架构(Architecture)，但它们背后的思想是相同的。&lt;/p&gt;

&lt;p&gt;有些新手可能会觉得引擎、框架这些东西都是大牛开发的，我们只要会用就好了。但其实事情不论大小，只要有套路可寻，都可以用引擎式思维去解决。在你的日常要解决的问题中，粗看可能各不相同，但这时你若退后一步，从一个更高地视角去发现问题之间的共同点，把解决方案中通用的部分从具体的问题中抽离出来，这时你就有了自己的框架。这是程序员的一种核心能力，它不会因为技术的日新月异而过时，但你也不可能一跃而蹴，它会随着你技术能力的成熟而逐渐精进。就如同武侠小说里的内功，难以速成，但却比学习任何具体的招式都更重要。&lt;/p&gt;

&lt;h2 id=&quot;从一个例子讲起&quot;&gt;从一个例子讲起&lt;/h2&gt;
&lt;p&gt;引擎未必是庞大而复杂的，它只是一种思想，也可以被用于解决小问题。我们来看个例子，假如有一天团队开始抓码质量，所有文件在提交之前都要做语法检查。这就需要利用 git hook 写一个 precommit 脚本，它会在每次 git commit 之前运行。不了解 git hook 的同学&lt;a href=&quot;https://git-scm.com/book/gr/v2/Customizing-Git-Git-Hooks&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;你用 Python 写了第一版的 precommit 脚本，代码如下，简单清晰没毛病。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;precommit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_commit_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'.py'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pylint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'.js'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;jslint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;过了两天，你团队的代码质量又进步了，对所有的 Python 模块加上了单元测试，这时就要求所有 Python 文件在提交前还需要跑对应的单元测试，如果单元测试不通过，就让提交失败。所以你改了一下 precommit 脚本&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;precommit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_commit_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'.py'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;py_unittest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'failed'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; 
               &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;pylint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'.js'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;jslint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然比之前稍丑了一些，但可读性还是可以的。大家在尝到了 precommit 脚本的甜头之后，更加变本加厉，各种需求接踵而来&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;“加上 Javascript 的单元测试吧”&lt;/li&gt;
  &lt;li&gt;“图片提交之前能不能用 TinyPNG 压缩一下”&lt;/li&gt;
  &lt;li&gt;“data.py 是数据文件，不需要运行单元测试”&lt;/li&gt;
  &lt;li&gt;“我们另一个 git repo 也想用你的 precommit 脚本，但要把 Python 的单元测试先禁掉”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1), 2)都是小意思，加上就行了。3)让你有点为难，precommit 函数已经有点长了，要不这个判断写在 &lt;code class=&quot;highlighter-rouge&quot;&gt;py_unittest&lt;/code&gt; 里吧。到了4)，你忍不住顶了回去“我没空写，拷贝一份自己去改吧！”&lt;/p&gt;

&lt;p&gt;这时你开始意识到这样下去不是办法，但别人的这些需求又很琐碎，让你没办法很好地组织代码。如果要系统化地解决这些问题，该怎么做呢？你发现所有的需求都可以抽象成同一个套路&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果文件名符合某个条件，就对该文件执行一个特定函数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果让使用者来提供文件名的条件以及要执行的函数，那么你只需要构建一个引擎来做条件判断，并为要执行的函数准备参数就行了。有了这个思路后，你把每个需求抽象成了一条规则，规则包含以下几个属性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;id: 规则的名字&lt;/li&gt;
  &lt;li&gt;include: 适合的文件名&lt;/li&gt;
  &lt;li&gt;exclude: 要剔除的文件名&lt;/li&gt;
  &lt;li&gt;func: 对符合条件的文件，要执行的函数&lt;/li&gt;
  &lt;li&gt;warning_only: 如果设为 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;，在 func 执行失败时，只打印警告。否则，中断提交。默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你把代码重构成了下面这个样子&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'pylint'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'include'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'*.py'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'func'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pylint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'warning_only'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'py-unittest'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'include'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'*.py'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'exclude'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data.py'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;'func'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;py_unittest&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;precommit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_commit_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;run_hooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;run_hooks&lt;/code&gt; 是你整个引擎的入口。而那些具体的需求不再是引擎的一部分，而只是外部输入。更进一步，你把 rules 放在一个单独的 JSON 或是 YAML 文件中。这样别的团队可以定制自己的 rules 配置文件，然后直接使用你的 precommit 引擎，这样就完美解决了之前的第4个需求。&lt;/p&gt;

&lt;p&gt;这里不给出 &lt;code class=&quot;highlighter-rouge&quot;&gt;run_hooks&lt;/code&gt; 的具体实现，有兴趣的同学可以自己写写看。&lt;/p&gt;

&lt;h2 id=&quot;避免过度设计&quot;&gt;避免过度设计&lt;/h2&gt;
&lt;p&gt;当你有了引擎思维之后，也要小心另一个极端，那就是过度设计。这里有两种情况，一种是过早地设计引擎，没有从实际的需求中去总结抽象，而是凭自己的臆测。对于一个了解业务的资深工程师来说，这样做也许是可行的，但如果你经验不足，还是别太相信你的预判。另一种过度设计是想让引擎能满足所有的需求，这可能让你的引擎变得复杂而难用。在设计引擎时，我也会使用80/20原则，让引擎能很好地解决80%的需求，对于剩下的20%，引擎需要有一种 fallback 机制，它只要做到不挡道，能让使用者自己去解决这些需求就行了。过度设计可以聊的点很多，将来可以单独发文讨论，这里就此打住。&lt;/p&gt;

&lt;h2 id=&quot;培养引擎式思维&quot;&gt;培养引擎式思维&lt;/h2&gt;
&lt;p&gt;我是在工作几年之后，才逐渐有引擎式思维的意识。对于每个待解决的问题，开始问自己“它是不是某类问题中的一个个例，这类问题能否被系统化地解决”，而随着经验地增长，越来越多的时候我会得出肯定的答案。因为这是一个长时间累积的过程，我鼓励大家尽早地思考这个问题，对你的技术进步一定会有帮助的。&lt;/p&gt;

&lt;p&gt;从另一个角度，如果你已经是团队中的技术领导，在与团队成员的技术讨论中，在 Code Review 时，你该教他们些什么？Coding style, 某种语言的语法糖，一个可以解决他们手头问题的第三方库？这些是必要的，但还不够。初出茅庐的小伙伴们可能为了完成布置的任务就已经疲于奔命了，或是沉醉在某项新技术的学习中，但他们未必会有意识地去思考如何搭建一个引擎来解决一类问题。在这方面，初期他们需要有好的范例去模仿，中期需要有人提醒指引，日久之后他们才会自发地造引擎，在中前期一个优秀的技术领导若给于他们这方面的帮助，就能大大加速他们核心能力的成长。我觉得这是培养团队成员的重要一环。&lt;/p&gt;

&lt;p&gt;今天的分享就到这里，希望对大家能有所启发，欢迎留言讨论。&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/06/engine-thinking/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/06/engine-thinking/</guid>
      </item>
    
      <item>
        <title>数据可视化的开源方案: Superset vs Redash vs Metabase (二)</title>
        <description>&lt;p&gt;在挑选开源的数据可视化项目时，我主要看重以下三个方面&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;功能, 易用性与文档&lt;/li&gt;
  &lt;li&gt;关注度与活跃度&lt;/li&gt;
  &lt;li&gt;源码的架构与质量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这些基本要求满足以后，我会看重它是否有REST API，能否通过API来创建与管理报表。为什么这很重要呢？&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果一个项目有出色REST API，它就很容易与其它系统对接。并且可以在不改动源码的前提下，做很多的二次开发。&lt;/li&gt;
  &lt;li&gt;公司的报表有很多是类似，用API来创建这些报表可以避免人工重复劳动，减少错误。&lt;/li&gt;
  &lt;li&gt;如果通过API来创建报表，我们就可以把报表的定义以JSON或是YAML的形式写在单独的配置文件中，并用版本控制系统来管理它。这对追踪修改历史有很大的好处。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;关注度与活跃度&quot;&gt;关注度与活跃度&lt;/h4&gt;

&lt;p&gt;看一个项目在Github上有多少个加星，是评判一个项目成熟度最快速的方法（虽然不一定准）。那除了星数以外，项目的github页面上还有什么重要信息呢？这里我建议大家去看一看项目的Insights。比如Superset的2017年12月的Insight数据如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/superset-insight.png&quot; alt=&quot;Superset Insight&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它告诉我们这个项目目前是否仍在积极开发中，为项目做主要贡献的一个人还是一个团队，项目维护者是否有及时地处理PR与Issues。这些都是项目健康状况的风向标。接下来我们就对比一下3个项目在github上的指标（截至2017年12月31日）&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目&lt;/th&gt;
      &lt;th&gt;Github星数&lt;/th&gt;
      &lt;th&gt;上月Commit数量&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Superset&lt;/td&gt;
      &lt;td&gt;17.4k&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Redash&lt;/td&gt;
      &lt;td&gt;8.1k&lt;/td&gt;
      &lt;td&gt;71&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Metabase&lt;/td&gt;
      &lt;td&gt;7.9k&lt;/td&gt;
      &lt;td&gt;187&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;虽然Superset在星数上遥遥领先于Redash与Metabase，但从当月commit数上来讲，它与Redash相近，落后于Metabase。而且Superset有一大半的Commit是来同一个人的，这对于一个复杂的BI系统来说不是一个理想状态。&lt;/p&gt;

&lt;h4 id=&quot;源码的架构与质量&quot;&gt;源码的架构与质量&lt;/h4&gt;

&lt;p&gt;在REST API方面，Redash也做得非常出色，不但所有操作都有对应的API，而且也原生支持API Token的认证方式，这使得它与其它系统的对接非常方便。&lt;/p&gt;

&lt;p&gt;Superset对图表和报表的所有操作都有API，当初我们从Looker迁移几百张图表到Superset的时候，就是通过写脚本调用Superset的API完成的。但Superset在设计认证方式的时候，还是全部基于Cookie的，所以在调API的时候要模拟一个用户登录的Session。如果有基于API Token的认证方式，用程序调用API会更简单。后来我们Fork了Superset的代码，加上了API Token的认证方式。&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/31/superset-redash-metabase2/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/31/superset-redash-metabase2/</guid>
      </item>
    
      <item>
        <title>数据可视化的开源方案: Superset vs Redash vs Metabase (一)</title>
        <description>&lt;p&gt;人是视觉动物，要用数据把一个故事讲活，图表是必不可少的。如果你经常看到做数据分析同事，在SQL客户端里执行完查询，把结果复制/粘贴到 Excel 里再做成图表，那说明你的公司缺少一个可靠的数据可视化平台。数据可视化是 Business Intelligence（BI）中的核心功能，有许多成熟的商用解决方案，如老牌的 Tableau，Qilk，新生代的 Looker，国内的 FineBI 等等。不过对于许多小公司来说，这些服务的 License 费用是一笔不小的开销，且有一种“杀鸡用牛刀”的感觉。那在开源软件如此发达的今天，在数据可视化方面，有什么靠谱的方案可以选择呢？今天给大家介绍三个比较知名的项目，分别是 Superset, Redash 和 Metabase。前两个我都在产生环境中实际使用过，在本文中会重点介绍。Metabase 我只是试玩了一下，但我觉得这是一个非常有想法的项目，所以也会和大家聊聊我对它的看法。&lt;/p&gt;

&lt;p&gt;选择一个称手的工具，功能上能满足我的需求肯定是首要的。就先从功能需求讲起，我们的数据仓库用的是 &lt;a href=&quot;https://docs.aws.amazon.com/zh_cn/redshift/latest/mgmt/welcome.html&quot;&gt;Amazon Redshift&lt;/a&gt;（如果你没听过 Redshift，就把它看作是为大数据优化过的 PostgreSQL），所以大部分的实际用例都是要将一个 SQL 查询的结果可视化。我们所需的图表类型也就是常用的那几种，包括折线图，柱形图，饼图等。有了图表之后，接下去就是把相关的图表排版，生成报表页面（Dashboard）。从数据安全性角度，我不希望每个员工都能自由访问所有的 Dashboard，所以每个 Dashboard 需要设置不同的访问级别。另外，我会看重它是否有 REST API，能否通过 API 来创建与管理报表，这部分我们放在以后的文章中再讲。&lt;/p&gt;

&lt;p&gt;除了满足功能性需求，易用性与文档在评判一个工具时也是非常重要的。谁不想要一个简单好用，文档清晰的产品呢？&lt;/p&gt;

&lt;p&gt;下面我们就从功能性、易用性与文档等方面，来看看这三个开源项目的实际表现吧&lt;/p&gt;

&lt;h2 id=&quot;superset&quot;&gt;Superset&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/superset-demo.gif&quot; alt=&quot;Superset Demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Superset 最初是由 Airbnb 的数据团队开源的，目前已进入 Apache Incubator，算是明星级的开源项目。老实讲，我也是被 Airbnb 与 Apache 两块金字招牌吸引才入了坑。目前公司绝大部分报表都在 Superset 上，大大小小有 50 个 Dashboard，包含了近 900 个图表。在使用 Superset 之前我们用的是 Looker（很不错的商用 BI 工具，可惜太贵），一年半前把 Looker 上所有的 Dashboard 迁移到 Superset 上，整个过程也很顺利。用了一年多，虽然在不少小地方有些不满意，但总体来说 Superset 很好地满足了公司现阶段在数据可视化与业务报表方面的需求。&lt;/p&gt;

&lt;p&gt;当你把一个数据库连接到 Superset 上以后，你需要定义要用到的每一张表。Superset 里表的定义除了字段，还需要定义指标（Metric）。指标是对字段的某种统计结果，比如字段上值的求和、平均值、最大值、最小值等。是不是有点糊涂了？但请回想一下，BI 工具通常是用来做商业分析的。假想一个电商数据库，虽然在数据表我们存储每笔订单的交易额，但在商业分析时我们不关心单笔交易，我们关心的可能是一个时间段内的总交额，或是平均交易额。当你画月报表时，你不会把每笔交易画在图上，而是把每天的总交易额用一个柱形在图上表示。这就是为什么 Superset 要引入“指标”这个概念。&lt;/p&gt;

&lt;p&gt;对于数据分析人员来说，由于在 Superset 上他们不是直接写 SQL，而是通过选择指标（Metric）, 分组条件（Group）和过滤条件（Filter）来画图表，所以在构建复杂查询时可能会有些不适应。另一个难题是 Superset 里的表不支持 join，如果一个图表里的数据要从多个数据表里取，那只能通过建视图来实现。Superset 在 0.11 版本之后加入 SQL Lab 功能，支持从 SQL 查询结果直接生成图表。可惜，由于这个功能与 Superset 的核心设计格格不入，所以实现得比较粗糙，没什么实用价值。&lt;/p&gt;

&lt;p&gt;客观地讲，Superset 里引入自己的表与指标的概念，在逻辑上是合理的，在统一各种异型的数据源时也是必要的。但实际操作中仍会让人觉得有些麻烦，不够直接了当。&lt;/p&gt;

&lt;p&gt;Superset 在可视化方面做得很出色，不但是开源领域中的佼佼者，也把很多商用 BI 工具甩在身后。在 0.20 版本中支持的图表类型已经达到了 36 种，而且在选择图表类型时，你可以看到每一种图表的缩略图，下面这张截图大家可以感受一下
&lt;img src=&quot;/images/superset-chart-types.png&quot; alt=&quot;Superset Chart Types&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Superset 的另一个亮点是可以在多个时间维度上观察，因为商业分析中的很多问题都是与时间密切相关的。Superset 有 4 种专门针对时间序列的图表，使用这些图表时，你需要指定一个字段为时间维度，之后就可以对时间维度做丰富的操作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从不同时间粒度去查看你关心的指标（小时/日/周/月/季度/年）&lt;/li&gt;
  &lt;li&gt;对时间序列做 rolling average，比如看一个指标的 7 日平均线&lt;/li&gt;
  &lt;li&gt;可以对时间序列做偏移，再做对比，比如把本周的销售业绩与上周同期放在一张图表中对比&lt;/li&gt;
  &lt;li&gt;不在图表上显示指标的绝对值，而是显示它随着时间变化的增长速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上这些都是在数据分析中非常实用的功能。&lt;/p&gt;

&lt;p&gt;说完优点，再说说 Superset 的槽点，最大的槽点是当图表与报表多了以后，管理不方便。这个问题其实很好解决，只要在图表和报表管理时，加上分组或是文件夹的概念就可以了，但至今未见类似的功能。现在公司 900 多个图表都在一个大列表下，虽然 Superset 支持搜索，过滤或是收藏，但查找起来还是太麻烦。&lt;/p&gt;

&lt;p&gt;Superset 的文档也比较糟糕，虽然在安装与快速入门方面提供了很完整的文档，但在具体功能的介绍方面文档严重缺失。就算有些功能有文档，文档的结构也很混乱，所以大部分功能只能自己去尝试，好在这个工具本身并不难用，自己去摸索各个功能也不太困难。&lt;/p&gt;

&lt;h2 id=&quot;redash&quot;&gt;Redash&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/redash-demo.gif&quot; alt=&quot;Redash Demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果说 Superset 是构建一个 BI 平台，那 Redash 目标就是更纯粹地做好数据查询结果的可视化。Redash 支持很多种数据源，除了最常用的 SQL 数据库，也支持 MongoDB, Elasticsearch, Google Spreadsheet 甚至是一个 JSON 文件。Redash 的官方文档里列出了它所支持的&lt;a href=&quot;https://redash.io/help-onpremise/setup/supported-data-sources-options-reqs.html&quot;&gt;所有数据源&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;它不需要像 Superset 那样在创建图表前先定义表和指标，而是可以非常直观地将一个 SQL 查询的结果可视化，这使得它上手很简易。或者说 Redash 仅仅实现了 Superset 中 SQL Lab 的功能，但却把这个功能做到了极致。&lt;/p&gt;

&lt;p&gt;Redash 有两个非常实用的功能，Query Snippet 与 Query Parameters。&lt;/p&gt;

&lt;p&gt;Query Snippet 很好地解决了查询片段的复用问题。做数据报表时经常要用到十分复杂的 SQL 语句，这些语句中肯定有一些片段是可以在多个查询中复用的。在 Redash 中我们可以将这些片段定义成 Snippet，之后方便地复用。&lt;/p&gt;

&lt;p&gt;Query Parameters 可以为查询添加可定制参数，让这个图表变得更灵活。比如一个移动应用的日活指标，我可能有时要按 iOS/Android 切分，有时要按地域切分，或是按新老用户切分。在 Superset 的 Dashboard 上我要做三个表图。Redash 里我可以把查询的 groupby 做为一个参数，这样就可以在一张图上搞定。用的时候，运营人员可以在图表上方的一个下拉框里选择切分的方式，非常直观好用。如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/redash-query-params.gif&quot; alt=&quot;Parameterized Query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Redash 的 Dashboard 可以通过命名来进行分组，Dashboard 的名字可以有一个前缀并以冒号结尾，前缀相同的 Dashboard 就会自动被分为一组。例如“ Growth: Daily ”，“ Growth: Weekly ”这两个 Dashboard 都会被分到“ Growth ”组下。&lt;/p&gt;

&lt;p&gt;相比 Superset，Redash 在文档方面做得更好，除了快速入门教程以外，每一个功能模块都有文档且条理清晰。&lt;/p&gt;

&lt;p&gt;当然 Redash 也有自己的不足之处，它的可视化种类比 Superset 逊色不少（不过其实也够用了）。另外，由于它只是纯粹地把数据查询结果可视化，所以也没有 Superset 里那些对时间维度上的聚合与对比的操作。&lt;/p&gt;

&lt;h2 id=&quot;metabase&quot;&gt;Metabase&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/metabase-demo.gif&quot; alt=&quot;Metabase Demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于我并没有在生产环境下使用过 Metabase，只在自己本本上试用过这个工具。所以我只能说一下对它的第一印象。&lt;/p&gt;

&lt;p&gt;刚开始用的就觉得这个工具的界面好漂亮，明显是经过 UI 设计师仔细调校过的。相对的，Superset 与 Redash 一看就是程序员充当设计师的产物。&lt;/p&gt;

&lt;p&gt;用了一会儿之后，我觉得 Metabase 与 Superset 虽然都想要打造一个完整的BI平台，但在理念上是不同的。Metabase 非常注重非技术人员（如产品经理、市场运营人员）在使用这个工具时的体验，让他们能自由地探索数据，回答自己的问题。而在 Superset 或是 Redash 里，非技术人员基本上只能看预先建好的 Dashboard，不懂 SQL 或是数据库结构的他们，很难自己去摸索。我非常喜欢 Metabase 的理念，它更接近一款成熟的商业化产品。当然要把这个理念变为现实是很有挑战的，目前我不知道在面临复杂的真实业务环境中，Metabase 是否有想像中那样美好。&lt;/p&gt;

&lt;p&gt;另外值得一提的是，Metabase 的文档也是三个项目中写得最好最完整的，内容非常丰富。&lt;/p&gt;

&lt;p&gt;将来若是有机会，我很愿意更深入地去体验这个产品。&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;本文简单地介绍了三个开源的数据可视化工具 Superset, Redash 和 Metabase，三者各有所长，我觉得并不存在绝对的最强者。对于刚刚开始搭建 BI 平台的公司，我相信它们都可以满足大部分报表与业务分析的需求。&lt;/p&gt;

&lt;p&gt;虽然 Superset 是我们公司现在主要使用的可视化工具，但我问过自己“如果现在让我重新选择，我会使用哪个开源项目？”我的答案是 Redash，原因主要不是功能层面，而是技术层面。这里正好可以引出我们下篇要聊的内容，从技术框架与源代码层面来比较一下这三个项目，以及我选择开源项目的一些通用原则，敬请期待！&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/31/superset-redash-metabase1/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/31/superset-redash-metabase1/</guid>
      </item>
    
      <item>
        <title>再见Evernote, 你好Orgmode</title>
        <description>&lt;p&gt;我这个人记性不好，所有的事情必须写下来才不会忘记。可偏偏字又写得难看，不然定会去买本精美的手账，随身带着。幸亏打字的速度不慢，所以一直靠键盘记事。记事的软件从最初的Word，到Google Notebook（这个项目后来关了，几年后又以Google Keep重生），再到Evernote，最近这些日子又看上了Orgmode。&lt;/p&gt;

&lt;h2 id=&quot;evernote&quot;&gt;Evernote&lt;/h2&gt;

&lt;p&gt;我是从2009年Google Notebook关站后，开始用Evernote的，至今也记了几千条的笔记。Evernote的CEO Phil说要把Evernote打造成人脑的延伸，瞬间让这个公司的愿景变得高大上起来，不过我倒是很认同这个说法，并不觉得浮夸。我在Evernote中的工作流程相当简单，有数量不多的Notebook，将笔记归为几个大类，像是工作，个人生活，技术知识等。我有两个Notebook stack，一个是Current Projects，一个是Project Archive，每一个进行中的项目都会在Current Projects的建一个独立Notebook，完成后的项目会被移到Project Archive中。 总体来说，这个流程工作得还不错，但Evernote要成为“人脑的延伸”还有很长的路要走（也不知它是否能撑到这天，近来都说这只独角兽不行了）。&lt;/p&gt;

&lt;p&gt;先说说Evernote的长处，它非常善于捕获信息，这些信息可以来自于web，图片，声音，PDF文档，电子邮件等等。无论是在桌面端还是移动端，任何时候你都可以轻松地将外界的信息导入到Evernote中。其次，它具有很强的全文检索功能，不但可以检索笔记中的文字，甚至连PDF或是图片中的文字都可以搜索出来。&lt;/p&gt;

&lt;p&gt;Evernote不足之处在于它的文本编缉与信息组织能力。先说文本编缉上的缺点，简而言之就是Evernote的写作体验不好，缺少Distraction-free模式，不支持Markdown。对于程序员而言，在笔记中无法方便地嵌入代码块也是一大硬伤。不过比起文本编缉，我觉得缺乏强大的信息组织能力，才是更致命的弱点。要先解释一下这里说的“信息组织”是指什么，为什么它重要？收录有价值的网页片段，或是记录你的工作日志，这只能算是原始素材的积累，它们需要被组织与提炼才能产生思想。人思考问题的方式不是自顶向下就是自下而上，最后的结果都是一个树状图，或称为层级结构。为了能记录下这种思考过程，我希望笔记软件提供两个功能&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;笔记需要支持层级结构。&lt;/li&gt;
  &lt;li&gt;笔记之间可以相互链接引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;打个比方，就像写一本书，你会先收集原始素材，然后开始由总纲开始，定义章节，小节，段落，再逐步细化。首先，Evernote的单个笔记中不存在层级关系，也无法折叠或是展开笔记中的某一个段落。其次，虽然Evernote支持笔记之间的引用，但不支持引用其他笔记中某个特定位置。若是把Evernote的笔记链接比做URL，那么它就是一个不支持带#的URL。因为这两个缺点，当Evernote里的笔记多了以后，笔记间的关系非常松散，很难对笔记的内容做二次提炼。&lt;/p&gt;

&lt;p&gt;这里我想提一下微软的OneNote。OneNote支持笔记间的层级关系，也可以生成不同层级粒度上的笔记链接，可以说完美解决了上节中提到的两大问题。不过微软在Mac上的产品，总有一种二等公民的感觉，所以我不太想用。但客观地讲，即使在Mac OSX上，OneNote也是一款比Evernote更出色的笔记软件。OneNote从去年开始发力，现在又是全平台，又是完全免费，Evernote前景堪忧啊…&lt;/p&gt;

&lt;h2 id=&quot;orgmode&quot;&gt;Orgmode&lt;/h2&gt;

&lt;p&gt;上一篇博客中提到最近我的主力编缉器从Vim转向Emacs。Orgmode做为Emacs上的杀手级应用，果然名不虚传，用了之后爱不释手。Orgmode的功能很难三言两语讲清楚，在GoogleTechTalks上有&lt;a href=&quot;https://www.youtube.com/watch?v=oJTwQvgfgMM&quot;&gt;一个著名的关于Orgmode的演讲&lt;/a&gt;。简单地说，你可以把Orgmode看成加强版的Markdown。Org文件里可以有无限深的层级，不但可以方便地折叠或是展开一个层级，也可以快速地在各层级间跳转。有不少Orgmode的使用者把整本书的内容写在一个org文件中，并能轻松地在各级目录间跳转。&lt;/p&gt;

&lt;p&gt;Orgmode的链接引用功能强大，几乎可以将所有资源都转化为链接。它不但可以指向一个URL，本地的一个文件，也可以指向一封电子邮件，或是org文件中某个具体的位置。最后一点尤为实用，比Evernote只能将整个笔记转化为一个链接，强太多了。&lt;/p&gt;

&lt;p&gt;Orgmode不仅是一个优秀的笔记软件外，还是一个出色的任务管理工具。在做项目时，我需要将项目分成多个任务，而在做每个任务时也会有工作笔记。在用Evernote的时候，我会需要一款任务管理软件来配合，像Trello, Asana或是Things。但我很不喜欢任务管理与任务笔记被分散在两个平台上的感觉。Orgmode将这两者合并为一个平台。&lt;/p&gt;

&lt;p&gt;Orgmode对于在笔记中内嵌代码有着完美的支持。不但如此，Orgmode还可以直接执行文档中的代码，并将执行结果输出到文档中，甚至做为文档中另一段代码的输入。这是一个非常强大的功能，但已超出本文要讨论的范围，有兴趣的可以看&lt;a href=&quot;http://youtu.be/1-dUkyn_fZA&quot;&gt;这个视频&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;除了以上说的几点之外，Orgmode中还有许多亮点，例如&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支持笔记模板。&lt;/li&gt;
  &lt;li&gt;可以专注于某个子章节，暂时隐藏文档中所有其他内容。&lt;/li&gt;
  &lt;li&gt;可以对整个文档加密。(Evernote只能加密笔记中的一部分内容)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后也是最重要的一点，因为Orgmode是Emacs的一部分，在写笔记时，可以100%利用Emacs强大的文本编缉功能。Orgmode也可以通过Emacs Lisp进行扩展，让我根据自己的工作流程来定制它。这种灵活性是Evernote或是OneNote无法比拟的。&lt;/p&gt;

&lt;p&gt;在Orgmode中，我的工作流程与在Evernote中略有不同。在用Orgmode时，我最常用的两个笔记文件是&lt;code class=&quot;highlighter-rouge&quot;&gt;tasks.org&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;journal.org&lt;/code&gt;。前者做任务管理，后者则是日志。在&lt;code class=&quot;highlighter-rouge&quot;&gt;tasks.org&lt;/code&gt;文件中包含所有待处理的任务，根据优先级分为&lt;code class=&quot;highlighter-rouge&quot;&gt;NEXT&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;SOON&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;SOMEDAY&lt;/code&gt;三级，完成的任务会被归档于&lt;code class=&quot;highlighter-rouge&quot;&gt;tasks.org_archive&lt;/code&gt;文件中。我用&lt;code class=&quot;highlighter-rouge&quot;&gt;journal.org&lt;/code&gt;来记录日志，包括每天做的所有事情以及产生的各种想法。日志文件以&lt;code class=&quot;highlighter-rouge&quot;&gt;journal_YYYY_MM.org&lt;/code&gt;方式命名，每个月会生成一个新文件, &lt;code class=&quot;highlighter-rouge&quot;&gt;journal.org&lt;/code&gt;是指向当月日志文件的一个link。每天会自动生成一个以日期为标题的新章节，不同的事件则记在自己的子标题下。&lt;/p&gt;

&lt;p&gt;我的笔记文件并不止以上两个，对于每一个我有兴趣的领域，我都会创建一个org文件（或是一个目录），例如&lt;code class=&quot;highlighter-rouge&quot;&gt;server-architecture.org&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;engineering-management.org&lt;/code&gt;等等。每周我会对日志文件进行整理，将其中有价值的内容提炼，添加到相应领域的文件中去，同时也会包含一个指向日志文件中原始笔记的链接。完成后，将日志文件中相应的日期标题置为“Reviewed”，这样在下次整理时我会很清楚哪些日期是还未整理的。二次提炼会驱使自己对问题做更深的思考与总结，益处颇多。&lt;/p&gt;

&lt;p&gt;我所有的笔记文件都在一个git repo下，同时也用Dropbox进行备份。&lt;/p&gt;

&lt;h2 id=&quot;orgmode--evernote&quot;&gt;Orgmode + Evernote&lt;/h2&gt;

&lt;p&gt;Orgmode唯一的不足之处是缺少移动端的支持，虽然有开源的&lt;a href=&quot;http://mobileorg.github.io/&quot;&gt;MobileOrg项目&lt;/a&gt;，但它的iOS版已经超过两年未更新了，app的界面更是已经古老到没办法看的地步。在移动端，我的主要需求是查阅过往的笔记。受&lt;a href=&quot;http://www.geeknote.me/&quot;&gt;Geeknote项目&lt;/a&gt;的启发，我写了一个&lt;a href=&quot;https://github.com/yejianye/eversync&quot;&gt;将Orgmode笔记同步到Evernote的程序&lt;/a&gt;。它的工作原理很简单，将一个git repo下所有的org文件，每一个文件生成一条对应的Evernote笔记，除普通文本外，还支持标题、列表、表格、待办事项等基本的Orgmode元素。通过这个工具，便可以在移动端利用Evernote的app来查阅我的Orgmode笔记了。&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;我依然在用Evernote收集网络上的素材，例如看到好的文章，我仍会用Evernote的web clipper全文摘录下来，以备将来搜索和查阅。但我已经很少在Evernote里写东西了，所有的记录与写作转移到了Orgmode里。我对目前的工作流程很满意，所以写成博文分享给大家。其实理论上来说，即使在Evernote，也可以采取记日志，定时整理的流程。只是Evernote不适合写结构化的笔记，用OneNote或是Orgmode会更有效。有兴趣的同学，欢迎留言讨论，或是写邮件给到&lt;a href=&quot;mailto:yejianye@gmail.com&quot;&gt;yejianye@gmail.com&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Sat, 14 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/11/14/bye-evernote-hello-orgmode/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/11/14/bye-evernote-hello-orgmode/</guid>
      </item>
    
      <item>
        <title>聊聊为什么我转投了Emacs</title>
        <description>&lt;p&gt;我用Vim已经8年了，虽然说不上是骨灰级用户，但我花在定制化Vim上的时间绝对不少，公司里的许多人也是在我怂恿之下才开始用Vim的。当年在Nvidia工作时，闲来无事，为公司Bug tracking系统写了一个Vim插件。离开多年后，依然有人在用，这似乎也是我在Nivdia唯一留下的东西，真不知道是该高兴还是悲哀。&lt;/p&gt;

&lt;p&gt;在聊为什么转投Emacs之前，我想先说说为何我对text editor如此重视。以前在我别的文章中也谈到，程序员的大部分时间在与代码打交道，好的文本编缉器能让你长期受益，所以有投资的价值。这也是为什么我会花时间在Vim，Emacs这种功能强大，但学习曲线陡峭的编缉器上。但这个理由其实还是留于表面，还有一个更重要的想法在驱使我去不断尝试。&lt;/p&gt;

&lt;p&gt;目前大家工作时用到的工具大致分为两类，一类是图形化界面的工具，像是Office, Evernote和IDE这些，另一类则是命令行工具，包括zsh, grep, make等。许多资深的程序员会更偏向于命令行工具，因为他们懂得unix的核心理念及其强大之处。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;合理地拼接组合使看似功能单一的几个工具变得强大而有无限多的可能性。同时，优秀的程序员往往会为自己写很多的实用工具，而开发一个命令行工具的代价要远远小于一个GUI工具。但另一方面，即使对于那些10x程序员来说，GUI工具依然有它的魅力。这魅力并不来自于它们华丽的界面，而来自于实实在在工作中效率地提升。通过图形化界面，可以为当前的工作提供大量的上下文信息，IDE中的Debugger就是一个典型的例子。另外，有些数据信息以图形的方式呈现，更容易让人理解，比如数据分析中常用的走势图，饼图，就比单纯的数字表格更易消化。&lt;/p&gt;

&lt;p&gt;虽然命令行工具与GUI工具如同光谱的两端，有着完全不同的理念，但我并不觉得它们是相互冲突的。我想要兼得两者的优点，更具体地说，我希望有这样一个平台&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在这个平台上开发工具，就如同开发命令行工具一样简单。&lt;/li&gt;
  &lt;li&gt;所有的工具都以纯文本做为输入与输出，可以相互合作。&lt;/li&gt;
  &lt;li&gt;平台上的工具可以充分利用屏幕呈现大量信息，合理地对屏幕信息布局&lt;/li&gt;
  &lt;li&gt;有显示图形的能力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在我看来，有着强大可扩展性的文本编缉器，有成为这种平台的潜质。无论是Vim, Emacs, Sublime或是Atom，都有一些功能强大让人赞叹的插件。你完全可以把这些编缉器看成是一个个操作系统，而那些插件则是其上的杀手级应用。&lt;/p&gt;

&lt;p&gt;绕了那么大一个圈子，让我回到原点，为什么我会转Emacs？因为在我所熟知的所有编缉器中，只有两个从一开始就想要成为平台，而不是单纯的编缉器，那就是Emacs和Atom。在编缉器圣战中，Vim的拥护者们经常挂在口中的一句话就是”The Emacs operating system needs a better editor.”，讽刺的背后也道出了Emacs的理念，正因为Emacs是一个操作系统，如今Emacs上的Evil插件几乎完全复制了Vim的核心功能，换句话说，Vim成了Emacs操作系统上的一款应用。Richard Stallman在编写Emacs时，先用20%的C代码创造了Emacs Lisp语言，然后用剩下的80% Elisp代码创造了整个编辑器。在之后的30年里，Elisp也被用于开发各种Emacs上的插件。也就是说Emacs的插件开发者与编缉器的创造者使用的是同样的工具，所以它的扩展性才那么被人称道。Emacs那超越所有同时代软件（以及绝大部分现代软件）的思想让我不得不钦佩。当然，Emacs满足我之前所提到的对于平台的所有要求，包括图形显示，通过几行代码，就可以实现把屏幕截图直接粘贴到Emacs中的功能。(如下图)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/emacs-screenshot.png&quot; alt=&quot;Emacs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后提一下Atom，它是另一个有着平台野心的编缉器，Github团队在编写Atom时创造了Electron，这是一个让开发者用web技术来搭建跨平台桌面应用的框架，比如现在大红大紫的Slack就是它开发的。从目前Atom的官方博客来看，Atom团队正在不留余力地推广Electron。我个人没有选择Atom的原因有两点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生态圈刚刚形成，插件数量还不够&lt;/li&gt;
  &lt;li&gt;虽然Web比桌面GUI要简单些，我仍然觉得编写Web界面的应用要比文本界面的应用复杂。(看到CSS就头大…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过我很看好Atom的未来，如果你觉得Emacs太古老，Atom是个不错的选择。&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/10/27/why-i-choose-emacs/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/10/27/why-i-choose-emacs/</guid>
      </item>
    
      <item>
        <title>Keyboard for hackers</title>
        <description>&lt;p&gt;5年前，在我刚工作不久之后，我买过花了500块买了IBM UltraNav Travel Keyboard，因为很喜欢当时IBM Thinkpad键盘的手感，所以买了这个与Thinkpad键盘手感完全相同的外置键盘，用于自己的台机。直到09年买了Macbook，那时的Macbook还是白色塑料外外壳的，俗称小白。小白的键盘手感非常好，并不逊色于Thinkpad。虽然小白的使用时间不到半年，在之后的日子一直用Macbook Pro但至今我仍这得小白键盘的手感要比MBP好些，mbp的键盘有点太软了。&lt;/p&gt;

&lt;p&gt;10天前入手了自己的第一块机械键盘Filco Ninja Brown，现在谈谈对这款键盘的感受&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/keyboard-filco.jpg&quot; alt=&quot;Filco Ninja Brown&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先由于是机械键盘，手感方面与薄膜键盘差别是很大的，每一次击键都有非常明确的反馈，按键的声音也比较大，刚开始可能会有一些不习惯，但很快就会喜欢上机械键盘的这种节奏感。对于以打字为主的使用者，网上有不少人推荐用青轴（Cherry MX Blue）的机械键盘。青轴击键的段落感更明确，按键的声音也更轻脆，而我买的是茶轴（Cherry MX Brown）。茶轴的优点是按键所需的力度较小，不易造成手指疲劳，按键的声音也较青轴要小。这款键盘并不是104键的，而是87键，键盘的长度与我的MBP相当，因为工作用的是本本，所以时常需要键盘带着一起走。这款键盘的尺寸我还是比较满意的。&lt;/p&gt;

&lt;p&gt;也谈谈它的缺点，首先虽然尺寸不大，键盘的份量相当重，大约有1.5公斤。另外键盘上并没有usb口，那于mbp这样只有两个usb口的本本来说，插上键盘与鼠标后，就没办法再插U盘或是别的外设了。&lt;/p&gt;

&lt;p&gt;在买filco ninja之前我看中的另一款键盘就是大名鼎鼎的HHKB（happy hacking keyboard），优点是小巧到极致，重量只有我这个键盘的1/3，上面还有2个扩展usb口。在手感方面因为我没有用过HHKB所以不好评价，但HHKB并不是一款机械键盘，而是静电容键盘，这是一种比较新的技术，同时也导致HHKB高昂的价格，淘宝上的价格大约为1800块，超静音版本在2200块。由于没有机会试用那款键盘，手感方面不好评价，但从网上现有的评论来看它的手感与机械键盘相比并无明显的优势。除了高价格之外，我没有选择HHKB的主要原因仅仅是因为它缺少了上下左右4个方向键。虽然在Termial和Vim中我并不需要方向键，但在大部分的应用程序和几乎所有的游戏中方向键都是必不可少。在HHKB上需要你按住fn key再加上另一个key才能模拟出方向键，如果这样来玩游戏的话，那简直就是噩梦。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/keyboard-hhkb.jpg&quot; alt=&quot;HHKB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HHKB有一个HHKB lite for mac，这个keyboard的布局在我心中可算得上是完美。（就是HHKB的极简布局加上4个方向键以及一个mac的fn key）非常可惜，这个lite版本是薄膜键盘而不是静电容键盘，希望将来会有HHKB Pro for mac。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/keyboard-hhkb-lite-mac.jpg&quot; alt=&quot;HHKB Lite for Mac&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了追求速度和击键爽快感的机械键盘外，另一类高端的键盘是讲究舒适性的人体工程学键盘，这类键盘中最知名的名牌是Kinesis。不过对于这类键盘我并不感冒，也知之甚少，或许若干年后如果我还在继续coding的话，会喜欢上它们。&lt;/p&gt;

&lt;p&gt;不少人觉得花近千元买一个键盘很不值，但其实一块好的机械键盘可以轻松使用5年以上，另外键盘技术的发展很慢，你不必担心今年买的高档键盘到了明年会落伍，恰恰相反，现在市场上被称为手感最出色的几款键盘都是80，90年代一些经典键盘的复刻。&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Mar 2013 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2013/03/03/keyboard-for-hackers/</link>
        <guid isPermaLink="true">http://localhost:4000/2013/03/03/keyboard-for-hackers/</guid>
      </item>
    
      <item>
        <title>Python - 合并多个进程的stdout和stderr</title>
        <description>&lt;p&gt;在开发中我们经常需要同时运行多个服务程序。以web开发为例，我们首先要启一个web server（django/flask/webpy/bottle等)，一个或多个db server（mysql/mongodb/redis等)，还可能用到一些watcher当源文件变化时自动编译(coffeescript/sass等）。如果这些程序运行在不同的terminal中，我们可能需要经常在这些terminal之间来回切换来查看它们的输出。因此我用python写了一个小的工具，用来在一个terminal中同时运行多个程序，合并它们的stdout和stderr。这个工具的工作原理很简单，启动时它读取一个配置文件并启动其中指定的若干个程序，之后它会捕获所有这些程序的输出，在每一行输出前加上对应程序的名字和进程ID，再输出到terminal上。它的代码加上帮助文档一共69行，麻雀虽小，却也用到了几个比较有意思的python模块，对初学python的朋友可以有一些帮助。以下是这个工具的完整代码&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;argh&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArghParser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;argparse&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;yaml&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;subprocess&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;select&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;fcntl&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_non_blocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcntl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fcntl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcntl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F_GETFL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fcntl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fcntl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fcntl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F_SETFL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;O_NONBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MultiRunner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd_objs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd_objs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd_objs&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start_process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subprocess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stdout_prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stderr_prefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s)|OUT'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s)|ERR'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout_prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stderr_prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_non_blocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd_objs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;has_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'command'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;'command' parameter is required for every process.&quot;&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'command'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;lines&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'[&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s] &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writelines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'name'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'command'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
        
&lt;span class=&quot;nd&quot;&gt;@arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'--config'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-f'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'multirun.yml'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Configuration file that specifies the commands to be executed.(default: multirun.conf)'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
    Launch multiple processes and manage all of their outputs together.
    Example of YAML-formatted config file
    ---
    name: proc1
    command: shell-command-to-start-proc1
    ---
    name: proc2
    command: shell-command-to-start-proc2
    &quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cmd_objs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yaml&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;runner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MultiRunner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd_objs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;runner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArghParser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;formatter_class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argparse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RawDescriptionHelpFormatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_default_command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先，这个工具用了&lt;code class=&quot;highlighter-rouge&quot;&gt;argh&lt;/code&gt;来处理命令行参数，可以在入口函数前用多个&lt;code class=&quot;highlighter-rouge&quot;&gt;@arg&lt;/code&gt;来指定多个命令行参数，并且使用入口函数的docstring来自动生成帮助，用起来比&lt;code class=&quot;highlighter-rouge&quot;&gt;optparse&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;argparse&lt;/code&gt;更方便。&lt;/p&gt;

&lt;p&gt;配置文件使用了yaml格式，与xml，json等格式相比，yaml更简洁，有更好的可读性，比如一个&lt;code class=&quot;highlighter-rouge&quot;&gt;dict(first_name='Ryan', last_name='Ye', description=&quot;I'm a software developer.\nLife  is short, you should use Python.&quot;)&lt;/code&gt;，转成yaml格式&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Ryan&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Ye&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;I&quot;m a software developer.&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;Life is short, you should use Python.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下去就是程序的主体部分，这里用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;subprocess&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;两个模块，&lt;code class=&quot;highlighter-rouge&quot;&gt;subprocess&lt;/code&gt;固名思义就是用来启动一个子进程，它的stdin, stdout和stderr是文件对象，stdin可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;方法写入，stdout, stderr可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;方法来读取。要同时监控若干个进程的输出有几种方法，最直观的方法是使用多线程，在每个线程中反复查询一个进程的输出，并对每一行输出加上进程名与进程ID后再用&lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt;输出。这个方法有一个问题，就是不同线程同时&lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt;时会造成最后的输出结果混乱。解决的方法是，把所有的输出写到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;中，再由一个单独的线程从&lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;中取出并&lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里并没有使用多线程模型，而是用了&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;方法的输入一堆文件对像，当其中的一个或是多个可读或可写时&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;函数就会返回，返回值就是所有可读写的文件对象。通过循环反复调用&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;就可以实现对多个文件的监控。特别要注意的是，这里必须把所有的文件读写模式设为非阻塞式(non-blocking I/O)，不然调用&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;方法时会一直等到相应的子进程退出才返回。各个不同的操作系统都实现了一套高效的select机制，详细的使用方法可以参见&lt;code class=&quot;highlighter-rouge&quot;&gt;epoll&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;kqueue&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;FSEvents&lt;/code&gt;等模块。基于select机制实现并发的模型，我们也常称为消息循环模型（event loop)。&lt;/p&gt;

&lt;p&gt;多线程模型和消息循环模型是在网络并发中常用的两个模型，消息循环模型由于没有线程切换的开销，所以一般来说性能上更占优。但由于它使用非阻塞式的I/O，所有的I/O操作都必须使用回调函数，使代码更复杂，影响可读性。这些年红红火火的gevent就是取两者之长，在最底层使用select机制来监控所有的I/O，根据I/O事件来调度coroutine，实现了接近于消息循环模型的性能，而应用程序的代码又可以用与多线程模型相同的方式来书写。&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Dec 2012 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2012/12/24/multirun/</link>
        <guid isPermaLink="true">http://localhost:4000/2012/12/24/multirun/</guid>
      </item>
    
      <item>
        <title>Retina Display上的编程字体</title>
        <description>&lt;p&gt;昨天刚刚入手新版的macbook pro，打开chrome浏览时，retina display下的文字效果的确让人惊叹。不过iTerm和vim下的文字显示效果提升却不是那明显，个人觉得主要是现在的主流等宽字体，包括consola, inconsolata，menlo等都没有对retina做优化。通过观察不难发现，纤细的字体在Retina下通常有更好的表现，可惜大部分的等宽字体都只有regular和bold两个样式，而没有light或是thin的样式。&lt;/p&gt;

&lt;p&gt;幸运的是，经过昨天一晚上的折腾终于找到了一款很适合Retina的等宽字体Source Code Pro，它是由Adobe发布的并且支持Extra Light, Light, Regular, Bold等许多种样式，个人觉得Light样式在iTerm和vim下的显示效果最为出色，以下是vim的截图，vim的theme是solarize dark。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/source-code-pro-screen.png&quot; alt=&quot;vim screenshot with source code pro&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个字体是免费的，有兴趣的朋友，可以在&lt;a href=&quot;https://github.com/adobe-fonts/source-code-pro&quot;&gt;这里下载&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 13 Dec 2012 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2012/12/13/programming-font-on-retina-display/</link>
        <guid isPermaLink="true">http://localhost:4000/2012/12/13/programming-font-on-retina-display/</guid>
      </item>
    
  </channel>
</rss>
